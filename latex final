\documentclass[12pt]{article}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}f
\setlength{\parindent}{0in}
\setlength{\parskip}{\baselineskip}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage[]{algorithmicx}
\usepackage{amsthm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength{\headsep}{36pt}
\usepackage{tkz-berge}
\usetikzlibrary{positioning, automata}

\theoremstyle{remark}
\newtheorem*{solution}{Solution}

\usepackage{hyperref}



\newcommand{\makenonemptybox}[2]{%
%\par\nobreak\vspace{\ht\strutbox}\noindent
\item[]
\fbox{% added -2\fboxrule to specified width to avoid overfull hboxes
% and removed the -2\fboxsep from height specification (image not updated)
% because in MWE 2cm is should be height of contents excluding sep and frame
\parbox[c][#1][t]{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
  \hrule width \hsize height 0pt
  #2
 }%
}%
\par\vspace{\ht\strutbox}
}
\makeatother

\begin{document}
\definecolor {processblue}{cmyk}{0.96,0,0,0}
\lhead{{\bf CSCI 3104, Algorithms \\ Final Exam - 100 pts total} }
\rhead{Name: \fbox{Samuel Ghalayini} \\ ID: \fbox{107338827} \\ {\bf Profs.\ Hoenigman \& Agrawal\\ Fall 2019, CU-Boulder}}
\renewcommand{\headrulewidth}{0.5pt}

\noindent
{\bf Notes:}
%\noindent
\begin{itemize}
\vspace{-4mm}
\item {\em Due date: 6pm on Sunday, December 8, 2019}
\vspace{-2mm}
\item {\em Submit a pdf file of your written answers to Gradescope and one py file with your Python codes to Canvas. All Python solutions should be clearly commented. Your codes need to run to get credit for your answers.}
\vspace{-2mm}
\item {\em You can ask clarification questions about the exam in office hours and on Piazza. However, please do not ask questions about how to answer a specific question. If there is confusion about any questions, we will address those issues at the beginning of class on December 5.}
\vspace{-2mm}
\item {\em All work on this exam needs to be independent. You may consult the textbook, the lecture notes and homework sets, but you should not use any other resources. If we suspect that you collaborated with anyone in the class or on the Internet, we will enforce the honor code policy strictly. If there is a reasonable doubt about an honor code violation,  you will fail this course.}
\end{itemize}
%\vspace{2mm}

\hrulefill
\vspace{-4mm}
\begin{enumerate}
\item (10 pts) Consider the following merge() algorithm to merge two sorted arrays into a larger sorted array. There are three errors in the algorithm. 
\begin{verbatim}
MergeWithErrors(A, p, q, r)
    low = A[p..q]
    high = A[q..r]
    i = 0
    j = 0
    k = p
    while(i < q-p+1 and j < r-q)
        if(low[i] <= high[j])
            A[k] = low[i]
            j++
        else
            A[k] = high[j]
            i++
        k++
    while(i < q-p+1)
        A[k] = low[i]
        i++
        k++
    while(j < r-q)
        A[k] = high[j]
        j++
        k++
\end{verbatim}
\pagebreak
\begin{enumerate}
    \item (5 pts) List the three errors in the MergeWithErrors algorithm.
    \begin{solution}
    :\\
    1. low array should be indexed from p to q+1 for bottom half of array\\
    2. high array should be indexed from q+1 to r+1 for second half of array\\
    3. Inside of first while loop the j++ and i++ should be swapped.\\
    Note: Should either change errors 1 and two or indexed in while loops for i from $i< q-p+1 \text{ to }i < p-q-1$
    \end{solution}
    \pagebreak
    
    \item (5 pts) For the following call to MergeWithErrors, what is the state of the array $A$ after running MergeWithErrors. You can assume that the size of $A$ won't change and values written outside the indices of $A$ will be lost.
    \\ $$A=[0,1,3,5,2,4,6,7]$$
     $$MergeWithErrors(A, 0, 3, 7)$$
    \begin{solution}
Array returned after running A through the MergeWithErrors with errors not resolved: [0,0,0,0,0,1,3,5]\\
    \end{solution}
    \pagebreak
    
\end{enumerate}


\item (25 pts) Let $G=(V,E)$ be a directed weighted graph of the pathways on the CU-Boulder campus, with edge weights being distances between different buildings/intersections. Engineering and Humanities are two vertices of $G$, and $k>0$ is a given integer. Assume that you will stop at every building/intersection you pass by. A shortest $k$-stop path is a shortest path between two vertices with exactly $k$ stops.
\begin{enumerate}
    \item (5 pts) Provide an example showing that the shortest $k$-stop path can't necessarily be found using Breadth-first search or Dijkstras algorithm. You need an example for each algorithm that shows where it fails.
    \begin{solution}
The Breadth-First search fails because at the end of the algorithm the k-stop is not the same as the optimal path found.
Dijkstra's algorithm also fails because it is looking for the shortest path to each node but the k-path is not always the shortest path.\\
\includegraphics[scale=.11, angle=-90]{dij.jpg}\\
\includegraphics[scale=.11, angle=0]{breadth.jpg}
    \end{solution}
    \pagebreak

    \item (10 pts) Design an algorithm to find the shortest path from Engineering to Humanities that contains exactly $k$ stops (excluding Engineering and Humanities). Notice that a $k$-stop path from these two buildings may not exist. So, your algorithm should also take care of such possibility. You need to provide an explanation of how your algorithm works to receive credit for this question.
    \begin{solution}
For this solution I've implemented a Bellman Ford algorithm to find the shortest path to each node. While the algorithm is optimizing each path I checked to see if the current and longest path is k-stops and after each optimization I've called a stop() function that checks to see if the current solution is at k-stops and if it is then return that path.\\ The Bellman Ford algorithm sets each vertex to infinity except the starting vertex (Engineering). As we go along each edge we update the cost to get to that edge. So after an edge is found and we follow an edge that lowers the cost to get to that vertex we can update the vertex cost so that is now optimal. It does this with the following recurrence relation (We are choosing the minimum from the current cost to get to that vertex which could be known or the cost to get to that parent vertex plus the edge weight we are traveling.):\\\\
%\begin{equation}
  Cost_i= min\begin{cases}
    \text{Previous cost of vertex}\\
    \text{New cost},\begin{equation}
    min\begin{cases}
    \text{previous cost of vertex}\\
    Cost_{v} + \text{edge weight}
    \end{cases}
    \end{equation}
  \end{cases}
%\end{equation}
    \end{solution}
    \pagebreak

    \item (10 pts) Implement your algorithm using the starter code provided on Canvas. 
    \\Done.
\end{enumerate}

\item (25 pts) To entertain her kids during a recent snowstorm, Dr. Hoenigman invented a card game called EPIC!. In the two-player game, an even number of cards are laid out in a row, face up so that players can see the cards' values. On each card is written a positive integer, and players take turns removing a card from either end of the row and placing the card in their pile. The objective of the game is to collect the fewest points possible. The player whose cards add up to the lowest number after all cards have been selected wins the game.
\\One strategy is to use a greedy approach and simply pick the card at the end that is the smallest. However, this is not always optimal, as the following example shows: (The first player would win if she would first pick the 5 instead of the 4.)

4 2 6 5

\begin{enumerate}
\item (10 pts) Write a non-greedy, efficient and optimal algorithm for a strategy to play EPIC!. The runtime needs to be less than or equals to $\Theta(n^2)$. Player 1 will use this strategy and Player 2 will use a greedy strategy of choosing the smallest card. \textbf{Note: Your choice of algorithmic strategy really matters here. Think about the types of algorithms we've learned this semester when making your choice.} You need to provide an explanation of how your algorithm works to receive credit for this question.
    \begin{solution}
I choose to solve this problem using a bottom up dynamic programming approach. My strategy was to chose the minimum card where if we chose one side then we also get the minimum between the inside two cards. And I ran this until we've filled up our matrix with the optimal costs for each card we can see. So if I chose the left card then that means its the optimal choice even after my opponent picks his/her card. The first for loop runs from i=0 to n-1, the whole array, and the nested for loop only runs from i to n so this algorithm runs in $\Theta(n^2)$.  \\The greedy approach that is also implemented is a basic test case to choose the minimum card between the two sides of the array until the array is empty.
    \end{solution}
    \pagebreak

\item (15 pts) Implement your strategy and the greedy strategy in Python and include code to simulate a game. Your simulation work for up to 100 cards (only consider the decks with even number of cards), and values ranging from 1 to 100. Your simulation should include a randomly generated collection of cards and show the sum of cards in each hand at the end of the game. \\
Done.
\end{enumerate}

\pagebreak
\item (22 pts) 
    In a previous homework assignment and classroom activity, we worked on the problem of finding the valley in an array, where array $A[1, 2, \cdots, n]$ with the property that the subarray $A[1..i]$ has the property that $A[j]>A[j+1]$ for $1\leq j< i$, and the subarray $A[i..n]$ has the property that $A[j]<A[j+1]$ for $i\leq j < n$. For example, $A=[16, 15, 10, 9, 7, 3, 6, 8, 17, 23]$ is a valleyed array. 
    
    \\Now consider the \textit{multi-valley} generalization, in which the array contains $k$ valleys, i.e., it contains $k$ subarrays, each of which is itself a valleyed array. Suppose that $k=2$ and we can guarantee that neither valley is closer than $n/4$ positions to the middle of the array, and that the ``joining point'' of the two singly-valleyed subarrays lays in the middle half of the array. 
    \begin{enumerate}
        \item (8 pts) Now write an algorithm that returns the minimum element of $A$ in sublinear time.
        \begin{solution}
\includegraphics[scale=.7, angle=0]{valley.png}    
        \end{solution}
        \pagebreak

        \item (10 pts) Prove that your algorithm is correct. (Hint:\ prove that your algorithm's correctness follows from the correctness of another correct algorithm we already know.)
        \begin{solution}
    
        \end{solution}
        \pagebreak

        \item (4 pts) Give a recurrence relation for its running time, and solve for its asymptotic behavior.
       \begin{solution}
    
        \end{solution}
        \pagebreak

    \end{enumerate}

\item (18 pts) Suppose we are given a set of non-negative distinct numbers $S$ and a target $t$. We want to find if there exists a subset of $S$ that sums up to \textbf{exactly} $t$ and the cardinality of this subset is $k$. 
\\Write a python program that takes an input array $S$, target $t$, and cardinality $k$, and returns the subset with cardinality $k$ that adds to $t$ if it exists, and returns $False$ otherwise. Your algorithm needs to run in $O(ntk)$ time where $t$ is the target and $n$ is the cardinality of $S$. In your code, provide a brief discussion of your runtime through comments, referring to specific elements of your code.\\
\\For example - 

Input: s = \{2,1,5,7\}, t = 4, k = 2\\
Output: False\\
Explanation:  No subset of size $2$ sums to 4.\\\\
Input: s = \{2,1,5,7\}, t = 6, k = 2\\
Output: \{1, 5\}\\
Explanation:  Subset \{1, 5\} has size 2 and sums up to the target $t = 6$.\\\\
Input: s = \{2,1,5,7\}, t = 6, k = 3\\
Output: False\\
Explanation:  No subset of size $3$ sums to 6.\\\\

\noindent
\end{enumerate}





\end{document}

